<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="Doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="thor.png"/></td>
  
  
  
   
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Math</div>  </div>
</div><!--header-->
<div class="contents">

<p>Mathematical functionality, such as random number generator or trigonometric wrappers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacethor_1_1_distributions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethor_1_1_distributions.html">thor::Distributions</a></td></tr>
<tr class="memdesc:namespacethor_1_1_distributions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for some predefined distribution functions. <br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_distribution.html">thor::Distribution&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class holding a rule to create values with predefined properties.  <a href="classthor_1_1_distribution.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_edge.html">thor::Edge&lt; V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge that contains two vertices (its endpoints or corners)  <a href="classthor_1_1_edge.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_triangle.html">thor::Triangle&lt; V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle class consisting of 3 vertices (its corners).  <a href="classthor_1_1_triangle.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthor_1_1_triangulation_traits.html">thor::TriangulationTraits&lt; V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template to implement the Vertex concept.  <a href="structthor_1_1_triangulation_traits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthor_1_1_trigonometric_traits.html">thor::TrigonometricTraits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric traits template.  <a href="structthor_1_1_trigonometric_traits.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0000a52045009ecd7aa1ce2e9997c3ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga0000a52045009ecd7aa1ce2e9997c3ca">thor::random</a> (int min, int max)</td></tr>
<tr class="memdesc:ga0000a52045009ecd7aa1ce2e9997c3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an int random number in the interval [min, max].  <a href="#ga0000a52045009ecd7aa1ce2e9997c3ca"></a><br/></td></tr>
<tr class="memitem:ga5f93f23dcc2587f9795db26f1e4bfd37"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga5f93f23dcc2587f9795db26f1e4bfd37">thor::random</a> (unsigned int min, unsigned int max)</td></tr>
<tr class="memdesc:ga5f93f23dcc2587f9795db26f1e4bfd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unsigned int random number in the interval [min, max].  <a href="#ga5f93f23dcc2587f9795db26f1e4bfd37"></a><br/></td></tr>
<tr class="memitem:gac3c5b7892b131176740401ae0d2df0aa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#gac3c5b7892b131176740401ae0d2df0aa">thor::random</a> (float min, float max)</td></tr>
<tr class="memdesc:gac3c5b7892b131176740401ae0d2df0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a float random number in the interval [min, max].  <a href="#gac3c5b7892b131176740401ae0d2df0aa"></a><br/></td></tr>
<tr class="memitem:ga56cb2eb0e91fcac64ade2c77cb8094e7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga56cb2eb0e91fcac64ade2c77cb8094e7">thor::randomDev</a> (float middle, float deviation)</td></tr>
<tr class="memdesc:ga56cb2eb0e91fcac64ade2c77cb8094e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a float random number in the interval [middle-deviation, middle+deviation].  <a href="#ga56cb2eb0e91fcac64ade2c77cb8094e7"></a><br/></td></tr>
<tr class="memitem:ga850fc3446f615648303ab22dabd0ddb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga850fc3446f615648303ab22dabd0ddb1">thor::setRandomSeed</a> (unsigned long seed)</td></tr>
<tr class="memdesc:ga850fc3446f615648303ab22dabd0ddb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the random number generator.  <a href="#ga850fc3446f615648303ab22dabd0ddb1"></a><br/></td></tr>
<tr class="memitem:ga5574e6a3bfed531b608dedf10c204a83"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga5574e6a3bfed531b608dedf10c204a83"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga5574e6a3bfed531b608dedf10c204a83">thor::triangulate</a> (InputIterator verticesBegin, InputIterator verticesEnd, OutputIterator trianglesOut)</td></tr>
<tr class="memdesc:ga5574e6a3bfed531b608dedf10c204a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delaunay Triangulation.  <a href="#ga5574e6a3bfed531b608dedf10c204a83"></a><br/></td></tr>
<tr class="memitem:ga4edf30c13d71bc92e356fff83b3147a9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga4edf30c13d71bc92e356fff83b3147a9"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga4edf30c13d71bc92e356fff83b3147a9">thor::triangulateConstrained</a> (InputIterator1 verticesBegin, InputIterator1 verticesEnd, InputIterator2 constrainedEdgesBegin, InputIterator2 constrainedEdgesEnd, OutputIterator trianglesOut)</td></tr>
<tr class="memdesc:ga4edf30c13d71bc92e356fff83b3147a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained Delaunay Triangulation.  <a href="#ga4edf30c13d71bc92e356fff83b3147a9"></a><br/></td></tr>
<tr class="memitem:ga9a54b10837d9ef3962b632345eb00bc3"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga9a54b10837d9ef3962b632345eb00bc3"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga9a54b10837d9ef3962b632345eb00bc3">thor::triangulatePolygon</a> (InputIterator verticesBegin, InputIterator verticesEnd, OutputIterator trianglesOut)</td></tr>
<tr class="memdesc:ga9a54b10837d9ef3962b632345eb00bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygon Delaunay Triangulation.  <a href="#ga9a54b10837d9ef3962b632345eb00bc3"></a><br/></td></tr>
<tr class="memitem:gacbdb5237d9959671f07d2f632dbcbcbb"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:gacbdb5237d9959671f07d2f632dbcbcbb"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gacbdb5237d9959671f07d2f632dbcbcbb">thor::triangulatePolygon</a> (InputIterator verticesBegin, InputIterator verticesEnd, OutputIterator1 trianglesOut, OutputIterator2 edgesOut)</td></tr>
<tr class="memdesc:gacbdb5237d9959671f07d2f632dbcbcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygon Delaunay Triangulation.  <a href="#gacbdb5237d9959671f07d2f632dbcbcbb"></a><br/></td></tr>
<tr class="memitem:ga33211c47d6a511605721c388accbde7f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga33211c47d6a511605721c388accbde7f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga33211c47d6a511605721c388accbde7f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#ga33211c47d6a511605721c388accbde7f">thor::toDegree</a> (T radian)</td></tr>
<tr class="memdesc:ga33211c47d6a511605721c388accbde7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts radians to degrees. <br/></td></tr>
<tr class="memitem:gae3941444f20c9285e9b299e6ddcef97b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae3941444f20c9285e9b299e6ddcef97b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae3941444f20c9285e9b299e6ddcef97b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math.html#gae3941444f20c9285e9b299e6ddcef97b">thor::toRadian</a> (T degree)</td></tr>
<tr class="memdesc:gae3941444f20c9285e9b299e6ddcef97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts degrees to radians. <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5f96126ab4e73d089caaadfdd52fe723"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___math.html#ga5f96126ab4e73d089caaadfdd52fe723">thor::Pi</a></td></tr>
<tr class="memdesc:ga5f96126ab4e73d089caaadfdd52fe723"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number Pi (3.1415...)  <a href="#ga5f96126ab4e73d089caaadfdd52fe723"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Mathematical functionality, such as random number generator or trigonometric wrappers. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0000a52045009ecd7aa1ce2e9997c3ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thor::random </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an int random number in the interval [min, max]. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>min &lt;= max </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f93f23dcc2587f9795db26f1e4bfd37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int thor::random </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an unsigned int random number in the interval [min, max]. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>min &lt;= max </dd></dl>

</div>
</div>
<a class="anchor" id="gac3c5b7892b131176740401ae0d2df0aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float thor::random </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a float random number in the interval [min, max]. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>min &lt;= max </dd></dl>

</div>
</div>
<a class="anchor" id="ga56cb2eb0e91fcac64ade2c77cb8094e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float thor::randomDev </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>deviation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a float random number in the interval [middle-deviation, middle+deviation]. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>deviation &gt;= 0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga850fc3446f615648303ab22dabd0ddb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thor::setRandomSeed </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the seed of the random number generator. </p>
<p>Setting the seed manually is useful when you want to reproduce a given sequence of random numbers. Without calling this function, the seed is different at each program startup. </p>

</div>
</div>
<a class="anchor" id="ga5574e6a3bfed531b608dedf10c204a83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thor::triangulate </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>verticesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>verticesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>trianglesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delaunay Triangulation. </p>
<p>Triangulates a set of points in a way such that every resulting triangle's circumcircle contains no other than the own three points. This condition leads to a "beautiful" result, the triangles appear balanced. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">verticesBegin,verticesEnd</td><td>Iterator range to the points being triangulated. The element type V can be any type as long as thor::TriangulationTraits&lt;V&gt; is specialized. <br/>
 Note that the triangulation may meet problems at 4 co-circular points or at 3 or more collinear points. </td></tr>
    <tr><td class="paramname">trianglesOut</td><td>Output iterator which is used to store the computed triangles. The elements shall be of type <a class="el" href="classthor_1_1_triangle.html">thor::Triangle&lt;V&gt;</a>, where V is your (maybe const-qualified) vertex type. The resulting triangles reference the original vertices in [verticesBegin, verticesEnd[, so they must not be destroyed as long as you access the triangles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Output iterator after the last element written.</dd></dl>
<p>Const-correctness is propagated through the algorithm. That is, if <em>InputIterator</em> is a const_iterator, the triangle's template argument shall be const. </p>

</div>
</div>
<a class="anchor" id="ga4edf30c13d71bc92e356fff83b3147a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thor::triangulateConstrained </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>verticesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>verticesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>constrainedEdgesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>constrainedEdgesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>trianglesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constrained Delaunay Triangulation. </p>
<p>Performs a Delaunay triangulation while taking constraining edges into account. "Constrained" means edges which are supposed to be part of the triangulation, locally ignoring the Delaunay condition. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">verticesBegin,verticesEnd</td><td>Iterator range to the points being triangulated. The element type V can be any type as long as thor::TriangulationTraits&lt;V&gt; is specialized. <br/>
 Note that the triangulation may meet problems at 4 co-circular points or at 3 or more collinear points. </td></tr>
    <tr><td class="paramname">constrainedEdgesBegin,constrainedEdgesEnd</td><td>Iterator range to the constrained edges. The element type shall be <a class="el" href="classthor_1_1_edge.html">thor::Edge&lt;V&gt;</a>, where T specifies your vertex type. The edges must refer to vertices inside the range [verticesBegin, verticesEnd[. To get expected results, edges may not intersect (except at the end points; containing the same vertex is allowed). </td></tr>
    <tr><td class="paramname">trianglesOut</td><td>Output iterator which is used to store the computed triangles. The elements shall be of type <a class="el" href="classthor_1_1_triangle.html">thor::Triangle&lt;V&gt;</a>, where V is your vertex type. The resulting triangles reference the original vertices in [verticesBegin, verticesEnd[, so the vertices may not be destroyed as long as you access the triangles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Output iterator after the last element written.</dd></dl>
<p>Const-correctness is propagated through the algorithm. That is, if <em>InputIterator</em> is a const_iterator, the triangle's template argument shall be const. </p>

</div>
</div>
<a class="anchor" id="ga9a54b10837d9ef3962b632345eb00bc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thor::triangulatePolygon </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>verticesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>verticesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>trianglesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polygon Delaunay Triangulation. </p>
<p>Computes a Delaunay triangulation of the inside of a polygon. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">verticesBegin,verticesEnd</td><td>Iterator range to the points being triangulated. The element type V can be any type as long as thor::TriangulationTraits&lt;V&gt; is specialized. The order of the vertices is important, as the constrained edges are formed between consecutive points (and between the last and first point). If the vertices lead to crossing edges, the result is undefined. </td></tr>
    <tr><td class="paramname">trianglesOut</td><td>Output iterator which is used to store the computed triangles. The elements shall be of type <a class="el" href="classthor_1_1_triangle.html">thor::Triangle&lt;V&gt;</a>, where V is your vertex type. The resulting triangles reference the original vertices in [verticesBegin, verticesEnd[, so the vertices may not be destroyed as long as you access the triangles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Output iterator after the last element written.</dd></dl>
<p>Const-correctness is propagated through the algorithm. That is, if <em>InputIterator</em> is a const_iterator, the triangle's template argument shall be const. </p>

</div>
</div>
<a class="anchor" id="gacbdb5237d9959671f07d2f632dbcbcbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator1 , typename OutputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator1 thor::triangulatePolygon </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>verticesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>verticesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>trianglesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>edgesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polygon Delaunay Triangulation. </p>
<p>Computes a Delaunay triangulation of the inside of a polygon. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">verticesBegin,verticesEnd</td><td>Iterator range to the points being triangulated. The element type V can be any type as long as thor::TriangulationTraits&lt;V&gt; is specialized. The order of the vertices is important, as the constrained edges are formed between consecutive points (and between the last and first point). If the vertices lead to crossing edges, the result is undefined. </td></tr>
    <tr><td class="paramname">trianglesOut</td><td>Output iterator which is used to store the computed triangles. The elements shall be of type <a class="el" href="classthor_1_1_triangle.html">thor::Triangle&lt;V&gt;</a>, where V is your vertex type. The resulting triangles reference the original vertices in [verticesBegin, verticesEnd[, so the vertices may not be destroyed as long as you access the triangles. </td></tr>
    <tr><td class="paramname">edgesOut</td><td>Output iterator which can be used to store the outline of the polygon. Beginning at the edge between <em>verticesBegin</em> and <em>verticesBegin+1</em>, every edge is sequentially written to <em>edgesOut</em> (the edge between the last and first point included). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Output iterator after the last element written.</dd></dl>
<p>Const-correctness is propagated through the algorithm. That is, if <em>InputIterator</em> is a const_iterator, the triangle's and edge's template arguments shall be const. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga5f96126ab4e73d089caaadfdd52fe723"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float thor::Pi</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number Pi (3.1415...) </p>
<p>Pi has the same value as TrigonometricTraits&lt;float&gt;::pi(). </p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 12 2015 10:30:40 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
